defmodule Beaver.MIF do
  @doc """
  A MIF is NIF generated by LLVM/MLIR
  """
  require Beaver.Env
  alias Beaver.MLIR.{Type, Attribute}
  alias Beaver.MLIR.Dialect.{Arith, LLVM, Func, CF}
  use Beaver

  defmacro __using__(_opts) do
    quote do
      import Beaver.MIF
      @before_compile Beaver.MIF
      Module.register_attribute(__MODULE__, :defm, accumulate: true)
    end
  end

  defmacro __before_compile__(_env) do
    quote do
      @ir @defm |> Enum.reverse() |> Beaver.MIF.compile_definitions(__ENV__)
      def __ir__ do
        @ir
      end
    end
  end

  defp getter_symbol(ctx, t) do
    cond do
      Type.equal?(t, Type.i32(ctx: ctx)) -> "enif_get_int"
      Type.equal?(t, Type.i64(ctx: ctx)) -> "enif_get_int64"
      true -> raise "getter symbol not found"
    end
    |> Attribute.flat_symbol_ref()
  end

  defp maker_symbol(ctx, t) do
    cond do
      Type.equal?(t, Type.i32(ctx: ctx)) -> "enif_make_int"
      Type.equal?(t, Type.i64(ctx: ctx)) -> "enif_make_int64"
      true -> raise "maker symbol not found"
    end
    |> Attribute.flat_symbol_ref()
  end

  def arg_from_term(ctx, current, terms, successor, arg_err_block, env, type, index) do
    mlir ctx: ctx, block: current do
      one = Arith.constant(value: Attribute.integer(Type.i(32), 1)) >>> ~t<i32>
      zero = Arith.constant(value: Attribute.integer(Type.i(32), 0)) >>> ~t<i32>
      ptr = LLVM.alloca(one, elem_type: type) >>> ~t{!llvm.ptr}
      term = terms |> Enum.at(index)
      condition = Func.call([env, term, ptr], callee: getter_symbol(ctx, type)) >>> Type.i32()

      condition =
        Arith.cmpi(condition, zero, predicate: Arith.cmp_i_predicate(:ne)) >>> Type.i1()

      value = LLVM.load(ptr) >>> type
      CF.cond_br(condition, successor, arg_err_block) >>> []
      value
    end
  end

  def value_to_term(ctx, block, env, value) do
    mlir ctx: ctx, block: block do
      Func.call([env, value], callee: maker_symbol(ctx, MLIR.CAPI.mlirValueGetType(value))) >>>
        Beaver.ENIF.mlir_t(:term)
    end
  end

  @doc """
  getting the function type and entry block argument types of an mif, and the index of beam env
  """
  def mif_type(arg_num) do
    term_t = Beaver.ENIF.mlir_t(:term)
    arg_types = List.duplicate(term_t, arg_num) ++ [Beaver.ENIF.mlir_t(:env)]
    {Type.function(arg_types, [term_t]), arg_types, arg_num}
  end

  defp definition_to_func({call, expr}, env) do
    {name, args} = Macro.decompose_call(call)
    expr = Macro.postwalk(expr[:do], &Macro.expand(&1, env)) |> List.wrap()

    quote do
      args_num = unquote(length(args))
      {function_type, arg_types, env_index} = Beaver.MIF.mif_type(args_num)

      Beaver.MLIR.Dialect.Func.func unquote(name)(function_type: function_type) do
        region do
          casting_blk_0 = MLIR.Block.create()

          block _() do
            MLIR.Block.add_args!(Beaver.Env.block(), arg_types, ctx: Beaver.Env.context())
            env = MLIR.Block.get_arg!(Beaver.Env.block(), env_index)

            terms =
              Range.new(0, args_num - 1) |> Enum.map(&MLIR.Block.get_arg!(Beaver.Env.block(), &1))

            CF.br({casting_blk_0, []}) >>> []
          end

          arg_types = [
            unquote_splicing(
              for {:"::", _, [{_, _, nil}, t]} <- args do
                quote do
                  unquote(t)
                end
              end
            )
          ]

          MLIR.CAPI.mlirRegionAppendOwnedBlock(Beaver.Env.region(), casting_blk_0)

          arg_err = MLIR.Block.create()

          {exit_blk,
           [
             unquote_splicing(
               for {:"::", _line0, [{_arg, _line1, nil} = var, _]} <- args do
                 quote do
                   Kernel.var!(unquote(var))
                 end
               end
             )
           ]} =
            arg_types
            |> Enum.with_index()
            |> Enum.reduce({casting_blk_0, []}, fn {type, index}, {current, values} ->
              successor = MLIR.Block.create()
              MLIR.CAPI.mlirRegionAppendOwnedBlock(Beaver.Env.region(), successor)

              v =
                Beaver.MIF.arg_from_term(
                  ctx,
                  current,
                  terms,
                  successor,
                  arg_err,
                  env,
                  type,
                  index
                )

              {successor, values ++ [v]}
            end)

          mlir block: exit_blk do
            last_op = unquote_splicing(expr)
            ret = last_op |> Beaver.Walker.results() |> Enum.at(0)
            ret_term = Beaver.MIF.value_to_term(ctx, Beaver.Env.block(), env, ret)
            Beaver.MLIR.Dialect.Func.return(ret_term) >>> []
          end

          mlir block: arg_err do
            ret = Arith.constant(value: Attribute.integer(~t<i32>, -1111)) >>> ~t<i32>
            ret_term = Beaver.MIF.value_to_term(ctx, Beaver.Env.block(), env, ret)
            Beaver.MLIR.Dialect.Func.return(ret_term) >>> []
          end

          MLIR.CAPI.mlirRegionAppendOwnedBlock(Beaver.Env.region(), arg_err)
        end
      end
    end
  end

  def compile_definitions(definitions, env) do
    quote do
      ctx = Beaver.MLIR.Context.create()

      m =
        mlir ctx: ctx do
          module do
            require Beaver.MLIR.Dialect.Func
            alias Beaver.MLIR.Dialect.{Func, Arith, LLVM, CF}
            alias MLIR.{Type, Attribute}
            import Beaver.MLIR.Type
            Beaver.ENIF.populate_external_functions(ctx, Beaver.Env.block())
            unquote_splicing(Enum.map(definitions, &definition_to_func(&1, env)))
          end
        end
        |> MLIR.Operation.verify!(debug: true)
        |> MLIR.dump!()
        |> MLIR.to_string()

      MLIR.Context.destroy(ctx)
      m
    end
    |> Code.eval_quoted()
    |> elem(0)
  end

  defmacro op({:"::", _, [call, types]}, _ \\ []) do
    {{:., _, [{dialect, meta, nil}, op]}, _, args} = call

    quote do
      %Beaver.SSA{
        op: unquote("#{dialect}.#{op}"),
        arguments: unquote(args),
        ctx: Beaver.Env.context(),
        block: Beaver.Env.block(),
        loc: Beaver.MLIR.Location.file(name: "from_quoted", line: unquote(meta[:line]))
      }
      |> Beaver.SSA.put_results([unquote_splicing(List.wrap(types))])
      |> MLIR.Operation.create()
    end
  end

  defmacro defm(call, expr \\ []) do
    {name, args} = Macro.decompose_call(call)
    args = for {:"::", _, [arg, _type]} <- args, do: arg

    quote do
      @defm unquote(Macro.escape({call, expr}))
      def unquote(name)(unquote_splicing(args)) do
        %{jit: jit} = Agent.get(__MODULE__, & &1)

        Beaver.MLIR.CAPI.mif_raw_jit_invoke_with_terms(
          jit.ref,
          to_string(unquote(name)),
          unquote(args)
        )
      end
    end
  end

  def init_jit(module) do
    import Beaver.MLIR.Conversion
    ctx = MLIR.Context.create()
    Beaver.Diagnostic.attach(ctx)

    jit =
      ~m{#{module.__ir__()}}.(ctx)
      |> MLIR.Pass.Composer.nested("func.func", "llvm-request-c-wrappers")
      |> convert_scf_to_cf
      |> convert_arith_to_llvm()
      |> convert_index_to_llvm()
      |> convert_func_to_llvm()
      |> MLIR.Pass.Composer.append("finalize-memref-to-llvm")
      |> reconcile_unrealized_casts
      |> MLIR.Pass.Composer.run!(print: System.get_env("DEFM_PRINT_IR") == "1")
      |> MLIR.ExecutionEngine.create!()

    :ok = Beaver.MLIR.CAPI.mif_raw_jit_register_enif(jit.ref)

    Agent.start_link(fn -> %{ctx: ctx, jit: jit} end, name: module)
  end

  def destroy_jit(module) do
    %{ctx: ctx, jit: jit} = Agent.get(module, & &1)
    MLIR.ExecutionEngine.destroy(jit)
    MLIR.Context.destroy(ctx)
    Agent.stop(module)
  end
end
