defmodule Beaver.MIF do
  @doc """
  A MIF is NIF generated by LLVM/MLIR
  """
  require Beaver.Env
  use Beaver

  defmacro __using__(_opts) do
    quote do
      import Beaver.MIF
      @before_compile Beaver.MIF
      Module.register_attribute(__MODULE__, :defm, accumulate: true)
    end
  end

  defmacro __before_compile__(_env) do
    quote do
      {ir_str, _} = @defm |> Beaver.MIF.compile_definitions(__ENV__) |> Code.eval_quoted()
      @ir ir_str
      def __ir__ do
        @ir
      end
    end
  end

  def compile_definitions(definitions, env) do
    functions =
      for {call, expr} <- definitions do
        {name, args} = Macro.decompose_call(call)

        expr = Macro.postwalk(expr, &Macro.expand(&1, env))[:do] |> List.wrap()

        {types, vars_of_blk_args} =
          for {{:"::", _line0, [{_arg, _line1, nil} = var, t]}, index} <- Enum.with_index(args) do
            {t,
             quote do
               Kernel.var!(unquote(var)) = MLIR.Block.get_arg!(Beaver.Env.block(), unquote(index))
             end}
          end
          |> Enum.unzip()

        quote do
          Beaver.MLIR.Dialect.Func.func unquote(name)(
                                          function_type:
                                            Type.function(unquote(types), [Type.i64()])
                                        ) do
            region do
              block _() do
                MLIR.Block.add_args!(Beaver.Env.block(), [unquote_splicing(types)],
                  ctx: Beaver.Env.context()
                )

                unquote_splicing(vars_of_blk_args)
                last_op = unquote_splicing(expr)
                ret = last_op |> Beaver.Walker.results() |> Enum.at(0)
                Beaver.MLIR.Dialect.Func.return(ret) >>> []
              end
            end
          end
        end
      end

    quote do
      ctx = Beaver.MLIR.Context.create()

      m =
        mlir ctx: ctx do
          module do
            require Beaver.MLIR.Dialect.Func
            alias Beaver.MLIR.Dialect.Func
            alias MLIR.Type
            import Beaver.MLIR.Type

            Func.func enif_get_int(
                        sym_visibility: MLIR.Attribute.string("private"),
                        function_type: Type.function([Type.i64()], [Type.i64()])
                      ) do
              region do
              end
            end

            (unquote_splicing(functions))
          end
        end
        |> MLIR.to_string()

      MLIR.Context.destroy(ctx)
      m
    end

    # |> tap(&IO.puts(Macro.to_string(&1)))
  end

  defmacro op(
             {:"::", _,
              [
                call,
                types
              ]},
             _ \\ []
           ) do
    {{:., _, [{dialect, _, nil}, op]}, _, args} = call
    op = "#{dialect}.#{op}"

    quote do
      %Beaver.SSA{
        op: unquote("#{op}"),
        arguments: unquote(args),
        ctx: Beaver.Env.context(),
        block: Beaver.Env.block(),
        loc: Beaver.MLIR.Location.from_env(__ENV__),
        filler: fn ->
          []
        end
      }
      |> Beaver.SSA.put_results([unquote_splicing(List.wrap(types))])
      |> MLIR.Operation.create()
    end
  end

  defmacro defm(call, expr \\ []) do
    {name, args} = Macro.decompose_call(call)
    args = for {:"::", _, [arg, _type]} <- args, do: arg

    quote do
      @defm unquote(Macro.escape({call, expr}))
      def unquote(name)(unquote_splicing(args)) do
        import Beaver.MLIR.Conversion
        arguments = [unquote_splicing(args)]
        ctx = MLIR.Context.create()

        jit =
          ~m{#{__ir__()}}.(ctx)
          |> MLIR.Pass.Composer.nested("func.func", "llvm-request-c-wrappers")
          |> convert_scf_to_cf
          |> convert_arith_to_llvm()
          |> convert_index_to_llvm()
          |> convert_func_to_llvm()
          |> MLIR.Pass.Composer.append("finalize-memref-to-llvm")
          |> reconcile_unrealized_casts
          |> MLIR.Pass.Composer.run!(print: System.get_env("DEFM_PRINT_IR") == "1")
          |> MLIR.dump!()
          |> MLIR.ExecutionEngine.create!()

        :ok = Beaver.MLIR.CAPI.mif_raw_jit_register_enif(jit.ref)

        Beaver.MLIR.CAPI.mif_raw_jit_invoke_with_terms(
          jit.ref,
          to_string(unquote(name)),
          arguments
        )
      end
    end
  end
end
