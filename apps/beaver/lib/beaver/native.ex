defmodule Beaver.Native do
  @moduledoc """
  This module provide higher level interface to primitive data types and MemRefDescriptor C struct in [MemRef](https://mlir.llvm.org/docs/Dialects/MemRef/) dialect.
  It aims to manage memory with BEAM utility like ets and help a Erlang/Elixir function play well with function generated by MLIR and other NIFs.
  """

  alias Beaver.MLIR.CAPI

  def ptr(%mod{ref: ref}) do
    %__MODULE__.Ptr{
      ref: apply(CAPI, Module.concat(mod, :ptr), [ref]) |> check!(),
      element_module: mod
    }
  end

  def opaque_ptr(%mod{ref: ref}) do
    maker = Module.concat([mod, :opaque_ptr])

    %__MODULE__.OpaquePtr{
      ref: apply(CAPI, maker, [ref]) |> check!()
    }
  end

  def array(list, module, opts \\ [mut: false]) when is_list(list) do
    mut = Keyword.get(opts, :mut) || false
    func = if mut, do: "mut_array", else: "array"

    ref =
      apply(CAPI, Module.concat([module, func]), [
        Enum.map(list, &Fizz.unwrap_ref/1)
      ])
      |> check!()

    %__MODULE__.Array{ref: ref, element_module: module}
  end

  def to_term(%__MODULE__.Ptr{ref: ref, element_module: __MODULE__.OpaquePtr}) do
    apply(
      CAPI,
      Module.concat([__MODULE__.OpaquePtr, :primitive]),
      [ref]
    )
    |> check!()
  end

  def to_term(%mod{ref: ref}) do
    apply(
      CAPI,
      Module.concat([mod, :primitive]),
      [ref]
    )
    |> check!()
  end

  def bag(%{bag: bag} = v, list) when is_list(list) do
    %{v | bag: MapSet.union(MapSet.new(list), bag)}
  end

  def bag(%{bag: bag} = v, item) do
    %{v | bag: MapSet.put(bag, item)}
  end

  def c_string(value) when is_binary(value) do
    %__MODULE__.C.String{ref: check!(CAPI.beaver_raw_get_resource_c_string(value))}
  end

  def check!(ref) do
    case ref do
      {:error, e} ->
        raise e

      ref ->
        ref
    end
  end
end
