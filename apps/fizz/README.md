# Fizz

Fizz (**F**oreign **i**nterface **z**eal in **Z**ig) is an Elixir package for binding a C library.
The zeal here is that an Erlang/Elixir developer shouldn't be required to write a NIF to call a C function.
The approach here is highly inspired by the TableGen/.inc source code generating in LLVM.
Fizz will generate NIF and proved Elixir macros to generate higher level API to call them and create resource.
NIF code generated and hand-rolled co-exist and complement each other.

## What Fizz does

- Make NIF more of a purely function dispatch. So that you can break the complicity among C/Zig and Elixir.
- Make it possible to pattern matching a C type in Elixir.
- Everything in Fizz could be a NIF resource, including primitive types like integer and C struct. This makes it possible to pass them to C functions as pointers.
- Fizz will generate a NIF function for every C function in your wrapper header, and register every C struct as NIF resource.

## Cool features in Fizz enabled by Zig

- Packing anything into a resource

  Almost all C++/Rust implementation seems to force you to map a fixed size type to a resource type.
  In fact for same resource type, you can have Erlang allocate memory of any size.
  With Zig's comptime `sizeof` you can easily pack a list of items into an array/struct without adding any abstraction and overhead. An illustration:

  ```
    [(address to item1), item1, item2, item3, ...]
  ```

  So the memory is totally managed by Erlang, and you can use Zig's comptime feature to infer everything involved.

- Saving lib/include path to a Zig source and use them in your `build.zig`. You can use Elixir to find all the paths. It is way better than configuring with make/CMake because you are using Elixir a whole programming language to do it. It is described in Zig doc as:

  > Surfacing build configuration as comptime values by providing a file that can be imported by Zig code.

- Inter NIF resource exchange. Because it is Zig, just import the Zig source from another Hex package.

## Core concepts

- `ResourceKind`: a Zig struct bundles C types and functions to open/fetch/make a resource object
- Recommended module mapping convention:

  - let's say you have a Elixir module to manage a C type. And the NIF module is `SomeLib.CAPI`

    ```elixir
    defmodule SomeLib.I64 do
      defstruct ref: nil
      def create() do
        ref = apply(SomeLib.CAPI, Module.concat([__MODULE__, :create]) |> Fizz.check!
        struct!(__MODULE__, %{ref: ref})
      end
    end
    ```

  - in `SomeLib.CAPI` there should be a NIF generated by Fizz with name `:"Elixir.SomeLib.I64.create"/0`

## Differences from Zigler

Fizz borrows a lot of good ideas and code from Zigler (Zigler is awesome~) but there are some differences:

- Fizz's primary goal is to help you consume a C library, not helping you write NIFs in Zig.
- Fizz expects you to have a `build.zig`. So if you want to also sneak CMake/Bazel inside, go for it.
- In functions generated by Fizz, all memory are allocated and managed by Erlang as resource.

## Differences from Rustler

Fizz is also inspired by Rustler. Rustler really define what a ergonomic NIF lib should be like.

- Fizz should have the sugar for resource open and NIF declaration similar to Rustler but are provided in Elixir (`nif_gen` and `type_gen`).
- Due to the absence of official Zig package indexing, as for now Fizz's approach could be more of a monolithic NIF lib while in Rustler, you can break things into different crates which is really nice.
- The only protection Fizz might provide is the resource type checks. Lifetime and other more sophisticated checks are expected to be provided by the C library you are consuming.

## Differences from TableGen

- Usually TableGen generates C/C++ source code. While in Fizz it is expected to generate Elixir AST and get compiled directly.
- Fizz takes in C `.h` files instead of `.td` files.

## Installation

If [available in Hex](https://hex.pm/docs/publish), the package can be installed
by adding `fizz` to your list of dependencies in `mix.exs`:

```elixir
def deps do
  [
    {:fizz, "~> 0.1.0"}
  ]
end
```

Documentation can be generated with [ExDoc](https://github.com/elixir-lang/ex_doc)
and published on [HexDocs](https://hexdocs.pm). Once published, the docs can
be found at <https://hexdocs.pm/fizz>.
